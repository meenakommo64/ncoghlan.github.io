<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<base href="http://www.curiousefficiency.org/posts/2011/02/index.html">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Posts/2011/02 | Curious Efficiency</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../rss.xml">
<link rel="canonical" href="http://www.curiousefficiency.org/posts/2011/02/index.html">
<!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-inverse navbar-static-top"><div class="container">
<!-- This keeps the margins nice -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://www.curiousefficiency.org/">

                <span id="blog-title">Curious Efficiency</span>
            </a>
        </div>
<!-- /.navbar-header -->
        <div class="collapse navbar-collapse" id="bs-navbar" aria-expanded="false">
            <ul class="nav navbar-nav">
<li>
<a href="../../../pages/about.html">About</a>
                </li>
<li>
<a href="../../../archive.html">Archives</a>
                </li>
<li>
<a href="../../../categories/index.html">Tags</a>
                </li>
<li>
<a href="../../../rss.xml">RSS</a>
                </li>
<li>
<a href="http://python-notes.curiousefficiency.org">Python Notes</a>

                
            </li>
</ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        <div class="row">
            
            
<div class="sectionindex">
    <header><h2><a href="#">Posts/2011/02</a></h2>
    </header><div class="postindex">
    <article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="status-quo-wins-stalemate.html" class="u-url">Status quo wins a stalemate</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="status-quo-wins-stalemate.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-27T15:07:00Z" title="2011-02-27 15:07">2011-02-27 15:07</time></a></p>
                <p class="commentline">
        
    <a href="status-quo-wins-stalemate.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/status-quo-wins-stalemate.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>Sometimes language design arguments can reach a point of stalemate. The status quo is only arguably flawed, and there are also perceived flaws in any or all of the proposed alternatives. An appropriate shared design principle can help identify when this point has been reached, and let the discussion die a natural death rather than endlessly rehashing the same points without anyone changing their opinion.<br><br>Every time we (python-dev) change anything significant, no matter how positive the end result, it can create a lot of churn in the community. Books need to be rewritten, other implementations modified, advice, recipes and examples updated, questions clarified as to which version they relate to, and version compatibility issues need to be monitored closely for projects that need to cope with older execution environments.<br><br>So, before any significant changes are made, we want to be fairly certain that the gain in clarity for future Python programs is worth the inevitable near term costs as the update ripples across the Python ecosystem. Sometimes newcomers have some interesting ideas, but still fail to clear this hurdle. The simple "it's not worth the hassle" response they're likely to receive may then come across as stodgy developers rejecting an outsider's ideas without adequate consideration.<br><br>This was something that came up fairly often during the Python 3000 mailing list discussions, to the point where I posted a message explaining why the principle of <a href="http://mail.python.org/pipermail/python-3000/2006-May/001936.html">"Status quo wins a stalemate"</a> is a very practical way to avoid meaningless churn in the language design and to cut short design discussions that obviously aren't going anywhere productive.<br><br>Python 3000 was already going to have a lot of major changes (most notably, finally improving the non-ASCII text handling story, in a way that means most Python 3 libraries and applications will be more likely to get it right). We needed to ride close herd on the design discussions to try to make sure that gratuitous changes with insufficient long term benefits were avoided.<br><br>So, lambda eventually stayed and map() and filter() were retained as builtins, while the attractive nuisance that is reduce() was merely banished to the functools module rather than getting dropped entirely as was originally proposed. PEP 348 was rejected to be replaced by the far less ambitious PEP 352. str.format() was still added, but as a complement to the legacy percent formatting mechanism rather than as a wholesale replacement.<br><br>Untold numbers of ideas on the mailing lists and the tracker were dropped with "too much pain for not enough benefit" as the rationale. More recently, PEP 3003 was instituted to enforce a moratorium on core language changes for Python 3.2 in order to give the rest of the community more time to catch up to Python 2.7 and the 3.x series, even though we knew it meant delaying good ideas like the improved generator refactoring capabilities provided by PEP 380.<br><br>The fact that Python 3 migration support tools like 2to3, 3to2 and the six module work as well as they do is probably due to this principle of language design as much as it is to any other factor (not to take anything away from the fine work that has gone into implementing them, of course!).</p>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="posting-code-and-syntax-highlighting.html" class="u-url">Posting code and syntax highlighting</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="posting-code-and-syntax-highlighting.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-27T09:43:00Z" title="2011-02-27 09:43">2011-02-27 09:43</time></a></p>
                <p class="commentline">
        
    <a href="posting-code-and-syntax-highlighting.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/posting-code-and-syntax-highlighting.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>Before publishing the previous post, I looked into recommendations for syntax highlighting in coding-oriented blogs. In a quick search, syntaxhighlighter showed up repeatedly as the preferred choice, so that's what I went with.<br><br>It looks like I'm not the only one <a href="http://www.knowthytools.com/2010/03/blogging-with-restructuredtext-and.html">that isn't entirely happy with that solution</a> (although by using the "pre" tags rather than "script", my code should at least appear in the RSS feed).<br><br>Working with ReST would certainly be easier than the semi-HTML I'm currently using. Still, I think I have plenty to learn about Blogger's formatting tools before I abandon them entirely in favour of preformatted posts (which have their own drawbacks).</p>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="justifying-python-language-changes.html" class="u-url">Justifying Python language changes</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="justifying-python-language-changes.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-27T09:13:00Z" title="2011-02-27 09:13">2011-02-27 09:13</time></a></p>
                <p class="commentline">
        
    <a href="justifying-python-language-changes.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/justifying-python-language-changes.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>A few years back, I <a href="http://mail.python.org/pipermail/python-dev/2008-October/082831.html">chipped in on python-dev</a> with a review of syntax change proposals that had made it into the language over the years. With Python 3.3 development starting and the language moratorium being lifted, I thought it would be a good time to tidy that up and republish it as a blog post.<br><br>Generally speaking, syntactic sugar (or new builtins) need to take a construct in idiomatic Python that is fairly obvious to an experienced Python user and make it obvious to even new users, or else take an idiom that is easy to get wrong when writing (or miss when reading) and make it trivial to use correctly.<br><br>Providing significant performance improvements (usually in the form of reduced memory usage or increased speed) also counts heavily in favour of new constructs.<br><br>I strongly suggest browsing through past PEPs (both accepted and rejected ones) before proposing syntax changes, but here are some examples of syntactic sugar proposals that were accepted.<br><br><b>List/set/dict comprehensions</b><br>(and the reduction builtins any(), all(), min(), max(), sum())<br></p>
<pre class="brush: py">target = [op(x) for x in source]</pre>instead of:<br><pre class="brush: py">target = []<br>for x in source:<br>    target.append(op(x))</pre>The transformation (`op(x)`) is far more prominent in the comprehension version, as is the fact that all the loop does is produce a new list. I include the various reduction builtins here, since they serve exactly the same purpose of taking an idiomatic looping construct and turning it into a single expression.<br><br><b>Generator expressions</b><br><pre class="brush: py">total = sum(x*x for x in source)</pre>instead of:<br><pre class="brush: py">def _g(source):<br>    for x in source:<br>        yield x*x<br>total = sum(_g(x))</pre>or:<br><pre class="brush: py">total = sum([x*x for x in source])</pre>Here, the GE version has obvious readability gains over the generator function version (as with comprehensions, it brings the operation being applied to each element front and centre instead of burying it in the middle of the code, as well as allowing reduction operations like sum() to retain their prominence), but doesn't actually improve readability significantly over the second LC-based version. The gain over the latter, of course, is that the GE based version needs a lot <i>less memory</i> than the LC version, and, as it consumes the source data<br>incrementally, can work on source iterators of arbitrary (even infinite) length, and can also cope with source iterators with large time gaps between items (e.g. reading from a socket) as each item will be returned as it becomes available (obviously, the latter two features aren't useful when used in conjunction with reduction operations like sum, but they can be helpful in other contexts).<br><br><b>With statements</b><br><pre class="brush: py">with lock:<br>    # perform synchronised operations</pre>instead of:<br><pre class="brush: py">lock.acquire()<br>try:<br>    # perform synchronised operations<br>finally:<br>    lock.release()</pre>This change was a gain for both readability and writability - there were plenty of ways to get this kind of code wrong (e.g. leave out the try-finally altogether, acquire the resource inside the try block instead of before it, call the wrong method or spell the variable name wrong when attempting to release the resource in the finally block), and it wasn't easy to audit because the resource acquisition and release could be separated by an arbitrary number of lines of code. By combining all of that into a single line of code at the beginning of the block, the with statement eliminated a lot of those issues, making the code much easier to write correctly in the first place, and also easier to audit for correctness later (just make sure the code is using the correct context manager for the task at hand).<br><br><b>Function decorators</b><br><pre class="brush: py">@classmethod<br>def f(cls):<br>    # Method body</pre>instead of:<br><pre class="brush: py">def f(cls):<br>    # Method body<br>f = classmethod(f)</pre>Easier to write (function name only written once instead of three times), and easier to read (decorator names up top with the function signature instead of buried after the function body). Some folks still dislike the use of the @ symbol, but compared to the drawbacks of the old approach, the dedicated function decorator syntax is a huge improvement.<br><br><b>Conditional expressions</b><br><pre class="brush: py">x = A if C else B</pre>instead of:<br><pre class="brush: py">x = C and A or B</pre>The addition of conditional expressions arguably wasn't a particularly big win for readability, but it <i>was</i> a big win for correctness. The and/or based workaround for the lack of a true conditional expression was not only hard to read if you weren't already familiar with the construct, but using it was also a potential source of bugs if A could ever be False while C was True (in such cases, B would be returned from the expression instead of A).<br><br><b>Except clause</b><br><pre class="brush: py">except Exception as ex:</pre>instead of:<br><pre class="brush: py">except Exception, ex:</pre>Another example of changing the syntax to reduce the potential for non-obvious bugs (in this case, except clauses like `except TypeError, AttributeError:`, that would actually never catch AttributeError, and would locally do AttributeError=TypeError if a TypeError was caught).
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="bye-bye-blogilo.html" class="u-url">Bye-bye Blogilo</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="bye-bye-blogilo.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-15T13:29:00Z" title="2011-02-15 13:29">2011-02-15 13:29</time></a></p>
                <p class="commentline">
        
    <a href="bye-bye-blogilo.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/bye-bye-blogilo.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <p>OK, when a blogging app can't figure out my blog identity automatically and crashes every time I submit a post (but after submitting the post to blogger), 'tis clearly not the app for me.<br><br>I'm just happy the first 3 posts didn't properly include the 'python' tag either, so at least Planet Python shouldn't have been spammed with any noise.<br><br>Back to the in-browser editor for now...</p>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="to-pycon-and-beyond_8775.html" class="u-url">To Pycon and beyond...</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="to-pycon-and-beyond_8775.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-15T13:21:00Z" title="2011-02-15 13:21">2011-02-15 13:21</time></a></p>
                <p class="commentline">
        
    <a href="to-pycon-and-beyond_8775.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/to-pycon-and-beyond_8775.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>All these Planet Python posts about interesting talks and info at Pycon finally tipped me over the edge into making the trek across the Pacific to meet some of these people I've been working with online for the past half-dozen years or so.</p>
<p>With 3.3 still 18-24 months away, we should be able to get a pretty good road map thrashed out for ideas we want to explore for possible inclusion. Some face-to-face discussions will be especially handy for me, given the things I'd like to see sorted out: module aliasing to clean up __main__ handling once and for all, bringing back implicit context managers now we have more collective experience with explicit ones, an alternative to PEP 377 that will allow context managers to do some additional setup inside the scope of the try block, clarifying the semantic questions raised by discrepancies between the PEP 3118 buffer API spec and its implementation.</p>
<p>I still have some paperwork to sort out once my renewed passport arrives, but aside from that, the trip is good to go. I did stuff my travel dates up a bit and will have a day to kill in Atlanta on the 9th, but I'm sure I'll be able to figure out something interesting to do :)</p>
</div>
    </div>
    </article><article class="h-entry post-text"><header><h1 class="p-name entry-title"><a href="linking-sites-in-blog-posts.html" class="u-url">Linking sites in blog posts</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">
                Nick Coghlan
            </span></p>
            <p class="dateline"><a href="linking-sites-in-blog-posts.html" rel="bookmark"><time class="published dt-published" datetime="2011-02-04T14:30:00Z" title="2011-02-04 14:30">2011-02-04 14:30</time></a></p>
                <p class="commentline">
        
    <a href="linking-sites-in-blog-posts.html#disqus_thread" data-disqus-identifier="cache/posts/2011/02/linking-sites-in-blog-posts.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>Call me paranoid, but the idea of trusting a blogging app with my Google account details really doesn't appeal to me. So, "BlogThis!" on the links bar it is.<br><br>It would be nice if BlogThis! popped up the full Blogger editor instead of a partial one (missing features like editing the post tags), but using it to save pre-linked drafts should be more than adequate for those occasions when I'm commenting on a link rather than writing something from scratch.</p>
<p>Test: editing an existing post...</p>
</div>
    </div>
    </article>
</div>



        
       <script>var disqus_shortname="boredomandlaziness";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
        <!--End of body content-->

        <footer id="footer">
            Contents © 2017 <a href="mailto:ncoghlan@gmail.com">Nick Coghlan</a> - <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>, republish as you wish. - Powered by <a href="http://nikola.ralsina.com.ar">Nikola</a>
            
        </footer>
</div>
</div>


            <script src="../../../assets/js/all-nocdn.js"></script><script>$('a.image-reference:not(.islink) img:not(.islink)').parent().colorbox({rel:"gal",maxWidth:"100%",maxHeight:"100%",scalePhotos:true});</script><!-- fancy dates --><script>
    moment.locale("");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</div>
</body>
</html>
