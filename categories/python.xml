<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Curious Efficiency (python)</title><link>http://www.curiousefficiency.org</link><description></description><language>en</language><lastBuildDate>Thu, 11 Dec 2014 16:46:32 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Running Kallithea on OpenShift</title><link>http://www.curiousefficiency.org/posts/2014/12/kallithea-on-openshift.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;div&gt;&lt;h2&gt;Kallithea for CPython&lt;/h2&gt;
&lt;p&gt;The CPython core development team are currently evaluating our options for
modernising our core development workflows to better match the standards
set by other projects and services like OpenStack and GitHub.&lt;/p&gt;
&lt;p&gt;The first step in &lt;a href="https://www.python.org/dev/peps/pep-0474/"&gt;my own proposal&lt;/a&gt;
for that is to migrate a number of the support repositories currently hosted
using a basic Mercurial server on hg.python.org to an instance of
&lt;a href="https://kallithea-scm.org/"&gt;Kallithea&lt;/a&gt; hosted as forge.python.org.
(Kallithea is a GPLv3 Python project that was forked from RhodeCode after
certain aspects of the latter's commercialisation efforts started alienating
several members of their user and developer community)&lt;/p&gt;
&lt;p&gt;Tymoteusz Jankowski (a contributor to Allegro Group's open source data centre
inventory management system, &lt;a href="http://ralph.allegrogroup.com/"&gt;Ralph&lt;/a&gt;), has
already started looking at the steps that might be involved in integrating a
Kallithea instance into the PSF's Salt based
&lt;a href="https://github.com/xliiv/psf-salt/tree/kallithea"&gt;infrastructure automation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, for my proposal to be as successful as I would like it to be, I need
the barriers to entry for the development and deployment of the upstream
Kallithea project itself to be as low as possible. One of the challenges
we've often had with gaining contributors to CPython infrastructure
maintenance is the relatively high barriers to entry for trying out service
changes and sharing them with others, so this time I plan to tackle that
concern &lt;em&gt;first&lt;/em&gt;, by ensuring that addressing it is a mandatory requirement
in my proposal.&lt;/p&gt;
&lt;p&gt;That means tackling two particular problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Having a way to easily run local test instances for development and
  experimentation&lt;/li&gt;
&lt;li&gt;Having a way to easily share demonstration instances with others&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the first problem, I plan to rely on Vagrant and Docker, while for the
second I'll be relying on the free tier in Red Hat's OpenShift Online
service. Unfortunately, while the
&lt;a href="http://www.openshift.org/"&gt;next generation&lt;/a&gt; of OpenShift will support Docker
images natively, for the time being, I need to tackle these as two separate
problems, as there aren't any existing Docker based services I'm aware of
with a free tier that is similarly suited to the task of sharing development
prototypes for open source web services with a broad audience (let alone
any such services that are also
&lt;a href="https://github.com/openshift"&gt;fully open source&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Once I have these working to my satisfaction, I'll propose them to the
Kallithea team for inclusion in the Kallithea developer documentation, but
in the meantime I'll just document them here on the blog.&lt;/p&gt;
&lt;h2&gt;Enabling Kallithea deployment on OpenShift&lt;/h2&gt;
&lt;p&gt;My first priority is to get a public demonstration instance up and running
that I can start tweaking towards the CPython core development community's
needs (e.g. installing the custom repo hooks we run on hg.python.org), so
I'm starting by figuring out the OpenShift setup needed to run public
instances - the Vagrant/Docker based setup for local development will come
later.&lt;/p&gt;
&lt;p&gt;Conveniently, WorldLine previously created an &lt;a href="https://github.com/worldline/openshift-rhodecode"&gt;OpenShift quickstart for
RhodeCode&lt;/a&gt; and published
it under the Apache License 2.0, so I was able to use that as a starting
point for my own
&lt;a href="https://github.com/ncoghlan/openshift-kallithea"&gt;Kallithea quickstart&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;While I personally prefer to run Python web services under mod_wsgi in order
to take advantage of Apache's authentication &amp;amp; authorisation plugin ecosystem,
that's not a significant concern for the demonstration server use case I have
in mind here. There are also some other aspects in the WorldLine quickstart
I'd like to understand better and potentially change (like figuring out a
better way of installing git that doesn't involve hardcoding a particular
version), but again, not a big deal for demonstration instances - rather
than worrying about them too much, I just annotated them as &lt;code&gt;TODO&lt;/code&gt; comments
in the OpenShift hook source code.&lt;/p&gt;
&lt;p&gt;I'd also prefer to be running under the official Python 2.7 cartridge rather
than a DIY cartridge, but again, my focus at this point is on getting
something up and running, and then iterating from there to improve it.&lt;/p&gt;
&lt;p&gt;That meant adapting the quickstart from RhodeCode to Kallithea was mostly
just a matter of changing the names of the various components being installed
and invoked, together with changing the actual installation and upgrade steps
to be based on Kallithea's deployment instructions.&lt;/p&gt;
&lt;p&gt;The keys to this are the
&lt;a href="https://github.com/ncoghlan/openshift-kallithea/blob/master/.openshift/action_hooks/build"&gt;build hook&lt;/a&gt;
and the
&lt;a href="https://github.com/ncoghlan/openshift-kallithea/blob/master/.openshift/action_hooks/start"&gt;start hook&lt;/a&gt;.
The &lt;a href="https://developers.openshift.com/en/managing-action-hooks.html"&gt;OpenShift docs&lt;/a&gt;
have more details on the various available action hooks and when they're run.&lt;/p&gt;
&lt;p&gt;In addition to the &lt;code&gt;TODO&lt;/code&gt; comments noted above, I also added various comments
explaining &lt;em&gt;what&lt;/em&gt; different parts of the action hook scripts were doing.&lt;/p&gt;
&lt;p&gt;(Note: I haven't actually &lt;em&gt;tested&lt;/em&gt; an upgrade, only the initial
deployment described below, so I can't be sure I have actually adapted the
upgrade handling correctly yet)&lt;/p&gt;
&lt;h2&gt;Deploying my own Kallithea instance&lt;/h2&gt;
&lt;p&gt;I already have an OpenShift account, so I could
&lt;a href="https://www.openshift.com/app/account/new"&gt;skip that step&lt;/a&gt;, and just
create a new app under my existing account. However, I didn't have the command
line tools installed, so that was the first step in creating my own instance:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;yum&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;rhc&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;yum is able to figure out on my behalf that it is &lt;code&gt;rubygems-rhc&lt;/code&gt; that
provides the command line tools for OpenShift in Fedora (alternatively,
I could have looked that up myself in the
&lt;a href="https://developers.openshift.com/en/getting-started-client-tools.html#fedora"&gt;OpenShift client tools installation docs&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The next step was to configure the command line tools to use my OpenShift
Online account, generate a local login token for this machine, and upload
my public SSH key to OpenShift Online. That process involved working through
the interactive prompts in:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;rhc&lt;/span&gt; &lt;span class="n"&gt;setup&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;With those preliminary OpenShift steps out of the way, it was time to
move on to deploying the application itself. It's worth noting that
app creation automatically clones a local git repo named after the application,
so I created a separate "app_repos" subdirectory in my development directory
specifically so I could call my OpenShift app "kallithea" without conflicting
with my local clone of the main kallithea repo.&lt;/p&gt;
&lt;p&gt;As described in the quickstart README, the app creation command is:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;rhc&lt;/span&gt; &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="n"&gt;kallithea&lt;/span&gt; &lt;span class="n"&gt;diy&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;0.1&lt;/span&gt; &lt;span class="n"&gt;postgresql&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;9.2&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;That churned away for a while, and then attempted to clone the app repo
locally over ssh (with SSH putting up a prompt to accept the validity of the
app's freshly generated SSH key). I'm not sure why, but for some reason that
automatic clone operation didn't work for me. &lt;code&gt;rhc&lt;/code&gt; put up a detailed
message explaining that the app creation had worked, but the clone step had
failed. Fortunately, as the troubleshooting notice suggested, a subsequent
&lt;code&gt;rhc git-clone kallithea&lt;/code&gt; worked as expected.&lt;/p&gt;
&lt;p&gt;OpenShift provides a default app skeleton automatically, but I actually
want to get rid of that and replace it with the contents of the quickstart
repo:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="n"&gt;diy&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;openshift&lt;/span&gt; &lt;span class="n"&gt;misc&lt;/span&gt; &lt;span class="n"&gt;README&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;md&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;commit&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="s"&gt;"Remove template files"&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;quickstart&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/ncoghlan/openshift-kallithea.git&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;pull&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;recursive&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;theirs&lt;/span&gt; &lt;span class="n"&gt;quickstart&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;The default merge commit message that popped up was fine, so I just accepted
that and moved on to the most interesting step:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Because this is the first build, there's a lot of output related to
installing and building the PostgreSQL driver and git, before moving on
to installing Kallithea and its dependencies.&lt;/p&gt;
&lt;p&gt;However, that still didn't take long, and completed without errors, so I now
have my own Kallithea instance
&lt;a href="http://kallithea-ncoghlan.rhcloud.com/"&gt;up and running&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And no, the default admin credentials created by the quickstart won't work
anymore - I immediately logged in to the admin account to change them!&lt;/p&gt;
&lt;h2&gt;Where to from here?&lt;/h2&gt;
&lt;p&gt;There are various aspects of the current quickstart that are far from ideal,
but I don't plan to spend a lot of time worrying about it when I know that
support for using Docker images directly in OpenShift is coming at some
point in the not too distant future.&lt;/p&gt;
&lt;p&gt;One of the key advantages of Docker is the much nicer approach it offers to
layered application development where infrastructure experts can provide
base images for others to build on, and in the case of deploying Python
applications with mod_wsgi, that means listening to Graham Dumpleton (the
author of mod_wsgi, currently working for New Relic).&lt;/p&gt;
&lt;p&gt;On that front, Graham has actually been
&lt;a href="http://blog.dscpl.com.au/2014/12/hosting-python-wsgi-applications-using.html"&gt;working on&lt;/a&gt;
creating a set of Debian based
&lt;a href="https://registry.hub.docker.com/u/grahamdumpleton/mod-wsgi-docker/"&gt;mod_wsgi Docker images&lt;/a&gt;
that Python developers can use, rather than having to build their own from
scratch.&lt;/p&gt;
&lt;p&gt;In my case, I'd really prefer something based on CentOS 7 or Fedora Cloud,
but that's a relatively minor quibble, and Graham's images should still make
a great basis for putting together a Vagrant+Docker based local workflow
for folks working on Kallithea.&lt;/p&gt;
&lt;p&gt;That, however, is a topic for a future post :)&lt;/p&gt;&lt;/div&gt;</description><category>docker</category><category>kallithea</category><category>openshift</category><category>python</category><guid>http://www.curiousefficiency.org/posts/2014/12/kallithea-on-openshift.html</guid><pubDate>Thu, 11 Dec 2014 03:18:26 GMT</pubDate></item><item><title>Seven billion seconds per second</title><link>http://www.curiousefficiency.org/posts/2014/09/seven-billion-seconds-per-second.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;div&gt;&lt;p&gt;A couple of years ago, YouTube put together their
&lt;a href="http://www.onehourpersecond.com/"&gt;"One hour per second"&lt;/a&gt; site, visualising
the fact that for every second of time that elapses, an hour of video is
uploaded to YouTube. Their
&lt;a href="https://www.youtube.com/yt/press/statistics.html"&gt;current statistics page&lt;/a&gt;
indicates that figure is now up to 100 hours per minute (about 1.7 hours per
second).&lt;/p&gt;
&lt;p&gt;Impressive numbers to be sure. However, there's another set of numbers I
personally consider significantly more impressive: every second, more than
seven billion seconds are added to the tally of collective human existence
on Earth.&lt;/p&gt;
&lt;p&gt;Think about that for a moment.&lt;/p&gt;
&lt;p&gt;Tick. Another 7 billion seconds of collective human existence.&lt;/p&gt;
&lt;p&gt;Tick. Another 117 million minutes of collective human existence.&lt;/p&gt;
&lt;p&gt;Tick. Another 2 million hours of collective human existence.&lt;/p&gt;
&lt;p&gt;Tick. Another 81 thousand days of collective human existence.&lt;/p&gt;
&lt;p&gt;Tick. Another 11 thousand weeks of collective human existence.&lt;/p&gt;
&lt;p&gt;Tick. Another 222 years of collective human existence.&lt;/p&gt;
&lt;p&gt;222 years of collective human experience, every single second, of every
single day. And as the world population grows, it's only going to get faster.&lt;/p&gt;
&lt;p&gt;222 years of collective human experience per second.&lt;/p&gt;
&lt;p&gt;13 centuries per minute.&lt;/p&gt;
&lt;p&gt;801 centuries per hour.&lt;/p&gt;
&lt;p&gt;19 millenia per day.&lt;/p&gt;
&lt;p&gt;135 millenia per week.&lt;/p&gt;
&lt;p&gt;7 billion years per year.&lt;/p&gt;
&lt;p&gt;The growth in our collective human experience over the course of a single
year would stretch halfway back to the dawn of time if it was experienced
by an individual.&lt;/p&gt;
&lt;p&gt;We currently squander most of that potential. We allow a lot of it to be
wasted scrabbling for the basic means of survival like food, clean water and
shelter. We lock knowledge up behind closed doors, forcing people to reinvent
solutions to already solved problems because they can't afford the entry fee.&lt;/p&gt;
&lt;p&gt;We ascribe value to people based solely on their success in the resource
acquisition game that is the market economy, without acknowledging the large
degree to which sheer random chance is frequently the determinant in who wins
and who loses.&lt;/p&gt;
&lt;p&gt;We inflict bile and hate on people who have the temerity to say "I'm here,
I'm human, and I have a right to be heard", while being different from us.
We often focus on those superficial differences, rather than our underlying
common humanity.&lt;/p&gt;
&lt;p&gt;We fight turf wars based on where we were born, the colour of our skin, and
which supernatural beings or economic doctrines we allow to guide our
actions.&lt;/p&gt;
&lt;p&gt;Is it possible to change this? Is it possible to build a world where we
consider people to have inherent value &lt;em&gt;just because they're fellow
humans&lt;/em&gt;, rather than because of specific things they have done, or specific
roles they take up?&lt;/p&gt;
&lt;p&gt;I honestly don't know, but it seems worthwhile to try. I certainly find it
hard to conceive of a better possible way to spend my own meagre slice of
those seven billion seconds per second :)&lt;/p&gt;&lt;/div&gt;</description><category>philosophy</category><category>politics</category><category>python</category><category>science</category><guid>http://www.curiousefficiency.org/posts/2014/09/seven-billion-seconds-per-second.html</guid><pubDate>Tue, 23 Sep 2014 07:35:39 GMT</pubDate></item><item><title>The transition to multilingual programming</title><link>http://www.curiousefficiency.org/posts/2014/08/multilingual-programming.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;div&gt;&lt;p&gt;A &lt;a href="https://mail.python.org/pipermail/python-dev/2014-August/135873.html"&gt;recent thread&lt;/a&gt;
on python-dev prompted
&lt;a href="https://mail.python.org/pipermail/python-dev/2014-August/135977.html"&gt;me to summarise&lt;/a&gt;
the current state of the ongoing industry wide transition from bilingual to
multilingual programming as it relates to Python's cross-platform support. It
also relates to the reasons why Python 3 turned out to be
&lt;a href="http://www.curiousefficiency.org/posts/2014/08/python-4000.html"&gt;more disruptive&lt;/a&gt;
than the core development team initially expected.&lt;/p&gt;
&lt;p&gt;A good starting point for anyone interested in exploring this topic further
is the &lt;a href="https://en.wikipedia.org/wiki/Unicode#Origin_and_development"&gt;"Origin and development"&lt;/a&gt;
section of the Wikipedia article on Unicode, but I'll hit the key points
below.&lt;/p&gt;
&lt;h2&gt;Monolingual computing&lt;/h2&gt;
&lt;p&gt;At their core, computers only understand single bits. Everything above that
is based on conventions that ascribe higher level meanings to particular
sequences of bits. One particular important set of conventions for
communicating between humans and computers are "text encodings": conventions
that map particular sequences of bits to text in the actual languages humans
read and write.&lt;/p&gt;
&lt;p&gt;One of the oldest encodings still in common use is
&lt;a href="https://en.wikipedia.org/wiki/ASCII"&gt;ASCII&lt;/a&gt; (which stands for "American
Standard Code for Information Interchange"), developed during the 1960's (it
just had its 50th birthday in 2013). This encoding maps the letters of the
English alphabet (in both upper and lower case), the decimal digits,
various punctuation characters and some additional "control codes" to the
128 numbers that can be encoded as a 7-bit sequence.&lt;/p&gt;
&lt;p&gt;Many computer systems today still only work correctly with English - when
you encounter such a system, it's a fairly good bet that either the system
itself, or something it depends on, is limited to working with ASCII text.
(If you're &lt;em&gt;really&lt;/em&gt; unlucky, you might even get to work with modal 5-bit
encodings like &lt;a href="https://en.wikipedia.org/wiki/ITA2#ITA2"&gt;ITA-2&lt;/a&gt;, as I have.
The legacy of the telegraph lives on!)&lt;/p&gt;
&lt;h2&gt;Working with local languages&lt;/h2&gt;
&lt;p&gt;The first attempts at dealing with this limitation of ASCII simply assigned
meanings to the full range of 8-bit sequences. Known collectively as
"Extended ASCII", each of these systems allowed for an additional 128
characters, which was enough to handle many European and Cyrillic scripts.
Even 256 characters was nowhere near sufficient to deal with Indic
or East Asian languages, however, so this time also saw a proliferation of
ASCII incompatible encodings like ShiftJIS, ISO-2022 and Big5. This is why
Python ships with support for
&lt;a href="https://docs.python.org/3/library/codecs.html#standard-encodings"&gt;dozens of codecs&lt;/a&gt;
from around the world.&lt;/p&gt;
&lt;p&gt;This proliferation of encodings required a way to tell software which
encoding should be used to read the data. For protocols that were originally
designed for communication between computers, agreeing on a common text
encoding is usually handled as part of the protocol. In cases where no
encoding information is supplied (or to handle cases where there is a
mismatch between the claimed encoding and the actual encoding), then
applications may make use of "encoding detection" algorithms, like those
provided by the &lt;a href="https://pypi.python.org/pypi/chardet"&gt;chardet&lt;/a&gt; package
for Python. These algorithms aren't perfect, but can give good answers when
given a sufficient amount of data to work with.&lt;/p&gt;
&lt;p&gt;Local operating system interfaces, however, are a different story. Not
only don't they inherently convey encoding information, but the nature of
the problem is such that trying to use encoding detection isn't practical.
Two key systems arose in an attempt to deal with this problem:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows code pages&lt;/li&gt;
&lt;li&gt;POSIX locale encodings&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With both of these systems, a program would pick a code page or locale, and
use the corresponding text encoding to decide how to interpret text for
display to the user or combination with other text. This may include
deciding how to display information about the contents of the computer
itself (like listing the files in a directory).&lt;/p&gt;
&lt;p&gt;The fundamental premise of these two systems is that the computer only needs
to speak the language of its immediate users. So, while the computer is
theoretically &lt;em&gt;capable&lt;/em&gt; of communicating in any language, it can effectively
only communicate with humans in one language at a time. All of the data a
given application was working with would need to be in a &lt;em&gt;consistent&lt;/em&gt;
encoding, or the result would be uninterpretable nonsense, something the
Japanese (and eventually everyone else) came to call
&lt;a href="https://en.wikipedia.org/wiki/Mojibake"&gt;mojibake&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It isn't a coincidence that the name for this concept came from an Asian
country: the encoding problems encountered there make the issues encountered
with European and Cyrillic languages look trivial by comparison.&lt;/p&gt;
&lt;p&gt;Unfortunately, this "bilingual computing" approach (so called because the
computer could generally handle English in addition to the local language)
causes some serious problems once you consider communicating &lt;em&gt;between&lt;/em&gt;
computers. While some of those problems were specific to network protocols,
there are some more serious ones that arise when dealing with nominally
"local" interfaces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;networked computing meant one username might be used across multiple
  systems, including different operating systems&lt;/li&gt;
&lt;li&gt;network drives allow a single file server to be accessed from multiple
  clients, including different operating systems&lt;/li&gt;
&lt;li&gt;portable media (like DVDs and USB keys) allow the same filesystem to be
  accessed from multiple devices at different points in time&lt;/li&gt;
&lt;li&gt;data synchronisation services like Dropbox need to faithfully replicate
  a filesystem hierarchy not only across different desktop environments,
  but also to mobile devices&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For these protocols that were originally designed only for local
interoperability communicating encoding information is generally difficult,
and it doesn't necessarily match the claimed encoding of the platform you're
running on.&lt;/p&gt;
&lt;h2&gt;Unicode and the rise of multilingual computing&lt;/h2&gt;
&lt;p&gt;The path to addressing the fundamental limitations of bilingual computing
actually started more than 25 years ago, back in the late 1980's. An initial
draft proposal for a 16-bit "universal encoding" was released in 1988, the
&lt;a href="https://en.wikipedia.org/wiki/Unicode_Consortium"&gt;Unicode Consortium&lt;/a&gt; was
formed in early 1991 and the first volume of the first version of
&lt;a href="https://en.wikipedia.org/wiki/Unicode"&gt;Unicode&lt;/a&gt; was published later that
same year.&lt;/p&gt;
&lt;p&gt;Microsoft added new text handling and operating system APIs to Windows based
on the 16-bit C level &lt;code&gt;wchar_t&lt;/code&gt; type, and Sun also adopted Unicode as part
of the core design of Java's approach to handling text.&lt;/p&gt;
&lt;p&gt;However, there was a problem. The original Unicode design had decided that
"16 bits ought to be enough for anybody" by restricting their target to
only modern scripts, and only frequently used characters within those
scripts. However, when you look at the "rarely used" Kanji and Han characters
for Japanese and Chinese, you find that they include many characters that
&lt;em&gt;are&lt;/em&gt; regularly used for the names of people and places - they're just
largely restricted to proper nouns, and so won't show up in a normal
vocabulary search. So Unicode 2.0 was defined in 1996, expanding the system
out to a maximum of 21 bits per code point (using up to 32 bits per code
point for storage).&lt;/p&gt;
&lt;p&gt;As a result, Windows (including the CLR) and Java now use the little-endian
variant of UTF-16 to allow their text APIs to handle arbitrary Unicode code
points. The original 16-bit code space is now referred to as the Basic
Multilingual Plane.&lt;/p&gt;
&lt;p&gt;While all that was going on, the POSIX world ended up adopting a different
strategy for migrating to full Unicode support: attempting to standardise on
the ASCII compatible UTF-8 text encoding.&lt;/p&gt;
&lt;p&gt;The choice between using UTF-8 and UTF-16-LE as the preferred local text
encoding involves some
&lt;a href="https://en.wikipedia.org/wiki/UTF-8#Advantages_and_disadvantages"&gt;complicated trade-offs&lt;/a&gt;,
and that's reflected in the fact that they have ended up being at the heart
of two competing approaches to multilingual computing.&lt;/p&gt;
&lt;p&gt;Choosing UTF-8 aims to treat formatting text for communication with the user
as "just a display issue". It's a low impact design that will "just work" for
a lot of software, but it comes at a price:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;because encoding consistency checks are mostly avoided, data in different
  encodings may be freely concatenated and passed on to other applications.
  Such data is typically not usable by the receiving application.&lt;/li&gt;
&lt;li&gt;for interfaces without encoding information available, it is often
  necessary to assume an appropriate encoding in order to display information
  to the user, or to transform it to a different encoding for communication
  with another system that may not share the local system's encoding
  assumptions. These assumptions may not be correct, but won't necessarily
  cause an error - the data may just be silently misinterpreted as something
  other than what was originally intended.&lt;/li&gt;
&lt;li&gt;because data is generally decoded far from where it was introduced, it
  can be difficult to discover the origin of encoding errors.&lt;/li&gt;
&lt;li&gt;as a variable width encoding, it is more difficult to develop efficient
  string manipulation algorithms for UTF-8. Algorithms originally designed
  for fixed width encodings will no longer work.&lt;/li&gt;
&lt;li&gt;as a specific instance of the previous point, it isn't possible to split
  UTF-8 encoded text at arbitrary locations. Care needs to be taken to ensure
  splits only occur at code point boundaries.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UTF-16-LE shares the last two problem, but to a lesser degree (simply due to
the fact most commonly used code points are in the 16-bit Basic Multilingual
Plane). However, because it &lt;em&gt;isn't&lt;/em&gt; generally suitable for use in network
protocols and file formats (without significant additional encoding markers),
the explicit decoding and encoding required encourages designs with a clear
separation between binary data (including encoded text) and decoded text
data.&lt;/p&gt;
&lt;h2&gt;Through the lens of Python&lt;/h2&gt;
&lt;p&gt;Python and Unicode were born on opposites side of the Atlantic ocean at
roughly the same time (1991). The growing adoption of Unicode within the
computing industry has had a profound impact on the evolution of the
language.&lt;/p&gt;
&lt;p&gt;Python 1.x was purely a product of the bilingual computing era - it had no
support for Unicode based text handling at all, and was hence largely
limited to 8-bit ASCII compatible encodings for text processing.&lt;/p&gt;
&lt;p&gt;Python 2.x was still primarily a product of the bilingual era, but added
multilingual support as an optional addon, in the form of the &lt;code&gt;unicode&lt;/code&gt;
type and support for a wide variety of text encodings.
&lt;a href="http://www.python.org/dev/peps/pep-0100/"&gt;PEP 100&lt;/a&gt; goes into the many
technical details that needed to be covered in order to incorporate that
feature. With Python 2, you &lt;em&gt;can&lt;/em&gt; make multilingual programming work, but
it requires an active decision on the part of the application developer,
or at least that they follow the guidelines of a framework that handles the
problem on their behalf.&lt;/p&gt;
&lt;p&gt;By contrast, Python 3.x is designed to be a native denizen of the
multilingual computing world. Support for multiple languages extends as far
as the variable naming system, such that languages other than English become
almost as well supported as English already was in Python 2. While the
English inspired keywords and the English naming in the standard library and
on the Python Package Index mean that Python's "native" language and the
preferred language for global collaboration will always be English, the new
design allows a lot more flexibility when working with data in other
languages.&lt;/p&gt;
&lt;p&gt;Consider processing a data table where the headings are names of Japanese
individuals, and we'd like to use &lt;code&gt;collections.namedtuple&lt;/code&gt; to process
each row. Python 2 simply can't handle this task:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;namedtuple&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;namedtuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"People"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;u"陽斗 慶子 七海"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s"&gt;"&amp;lt;stdin&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s"&gt;"/usr/lib64/python2.7/collections.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;310&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;namedtuple&lt;/span&gt;
    &lt;span class="n"&gt;field_names&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;field_names&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="ne"&gt;UnicodeEncodeError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;'ascii'&lt;/span&gt; &lt;span class="n"&gt;codec&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt;&lt;span class="s"&gt;'t encode characters in position 0-1: ordinal not in range(128)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Users need to either restrict themselves to dictionary style lookups rather
than attribute access, or else used romanised versions of their names
(Haruto, Keiko, Nanami for the example). However, the case of "Haruto" is an
interesting one, as there at least 3 &lt;em&gt;different&lt;/em&gt; ways of writing that as
Kanji (陽斗, 陽翔, 大翔), but they are all romanised as the same string
(Haruto). If you try to use romaaji to handle a data set that contains
more than one variant of that name, you're going to get spurious collisions.&lt;/p&gt;
&lt;p&gt;Python 3 takes a very different perspective on this problem. It says it
should just work, and it makes sure it does:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;namedtuple&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;namedtuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"People"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;u"陽斗 慶子 七海"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;陽斗&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;慶子&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;七海&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;This change greatly expands the kinds of "data driven" use cases Python can
support in areas where the ASCII based assumptions of Python 2 would cause
serious problems.&lt;/p&gt;
&lt;p&gt;Python 3 still needs to deal with improperly encoded data however, so it
provides a mechanism for arbitrary binary data to be "smuggled" through
text strings in the Unicode Private Use Area. This feature was added by
&lt;a href="http://www.python.org/dev/peps/pep-0383/"&gt;PEP 383&lt;/a&gt; and is managed through
the &lt;code&gt;surrogateescape&lt;/code&gt; error handler, which is used by default on most
operating system interfaces. This recreates the old Python 2 behaviour of
passing improperly encoded data through unchanged when dealing solely with
local operating system interfaces, but complaining when such improperly
encoded data is injected into another interface. The codec error handling
system provides several tools to deal with these files, and we're looking
at adding a few more relevant convenience functions for Python 3.5.&lt;/p&gt;
&lt;p&gt;The underlying Unicode changes in Python 3 also made
&lt;a href="http://www.python.org/dev/peps/pep-0393/"&gt;PEP 393&lt;/a&gt; possible, which changed
the way the CPython interpreter stores text internally. In Python 2, even
pure ASCII strings would consume four bytes per code point on Linux systems.
Using the "narrow build" option (as the Python 2 Windows builds from
python.org do) reduced that the only two bytes per code point when operating
within the Basic Multilingual Plane, but at the cost of potentially producing
&lt;em&gt;wrong answers&lt;/em&gt; when asked to operate on code points outside the Basic
Multilingual Plane. By contrast, starting with Python 3.3, CPython now
stores text internally using the smallest fixed width data unit possible.
That is, &lt;code&gt;latin-1&lt;/code&gt; text uses 8 bits per code point, &lt;code&gt;UCS-2&lt;/code&gt; (Basic
Multilingual Plane) text uses 16-bits per code point, and only text
containing code points outside the Basic Multilingual Plane will expand to
needing the full 32 bits per code point. This can not only significantly
reduce the amount of memory needed for multilingual applications, but may
also increase their speed as well (as reducing memory usage also reduces
the time spent copying data around).&lt;/p&gt;
&lt;h2&gt;Are we there yet?&lt;/h2&gt;
&lt;p&gt;In a word, no. Not for Python 3.4, and not for the computing industry at
large. We're much closer than we ever have been before, though. Most
POSIX systems now default to UTF-8 as their default encoding, and many
systems offer a &lt;code&gt;C.UTF-8&lt;/code&gt; locale as an alternative to the traditional
ASCII based &lt;code&gt;C&lt;/code&gt; locale. When dealing solely with properly encoded data and
metadata, and properly configured systems, Python 3 should "just work", even
when exchanging data between different platforms.&lt;/p&gt;
&lt;p&gt;For Python 3, the remaining challenges fall into a few areas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;helping existing Python 2 users adopt the optional multilingual features
  that will prepare them for eventual migration to Python 3 (as well as
  reassuring those users that don't wish to migrate that Python 2 is still
  fully supported, and will remain so for at least the next several years,
  and potentially longer for customers of commercial redistributors)&lt;/li&gt;
&lt;li&gt;adding back some features for working entirely in the binary domain that
  were removed in the original Python 3 transition due to an initial
  assessment that they were operations that only made sense on text data
  (&lt;a href="http://www.python.org/dev/peps/pep-0361/"&gt;PEP 361&lt;/a&gt; summary:
  &lt;code&gt;bytes.__mod__&lt;/code&gt; is coming back in Python 3.5 as a valid binary domain
  operation, &lt;code&gt;bytes.format&lt;/code&gt; stays gone as an operation that only makes sense
  when working with actual text data)&lt;/li&gt;
&lt;li&gt;better handling of improperly decoded data, including poor encoding
  recommendations from the operating system (for example, Python 3.5 will
  be more sceptical when the operating system tells it the preferred encoding
  is &lt;code&gt;ASCII&lt;/code&gt; and will enable the &lt;code&gt;surrogateescape&lt;/code&gt; error handler on
  &lt;code&gt;sys.stdout&lt;/code&gt; when it occurs)&lt;/li&gt;
&lt;li&gt;eliminating most remaining usage of the legacy code page and locale
  encoding systems in the CPython interpreter (this most notably affects the
  Windows console interface and argument decoding on POSIX. While these
  aren't easy problems to solve, it will still hopefully be possible to
  address them for Python 3.5)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;More broadly, each major platform has its own significant challenges to
address:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for POSIX systems, there are still a lot of systems that don't use UTF-8
  as the preferred encoding and the assumption of ASCII as the preferred
  encoding in the default &lt;code&gt;C&lt;/code&gt; locale is positively archaic. There is
  also still a lot of POSIX software that still believes in the "text is
  just encoded bytes" assumption, and will happily produce mojibake that
  makes no sense to other applications or systems.&lt;/li&gt;
&lt;li&gt;for Windows, keeping the old 8-bit APIs around was deemed necessary for
  backwards compatibility, but this also means that there is still a lot of
  Windows software that simply doesn't handle multilingual computing
  correctly.&lt;/li&gt;
&lt;li&gt;for both Windows and the JVM, a fair amount of nominally multilingual
  software actually only works correctly with data in the basic multilingual
  plane. This is a smaller problem than not supporting multilingual computing
  at all, but was quite a noticeable problem in Python 2's own Windows
  support.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Mac OS X is the platform most tightly controlled by any one entity (Apple),
and they're actually in the best position out of all of the current major
platforms when it comes to handling multilingual computing correctly. They've
been one of the major drivers of Unicode since the beginning (two of the
authors of the initial Unicode proposal were Apple engineers), and were able
to force the necessary configuration changes on all their systems, rather
than having to work with an extensive network of OEM partners (Windows,
commercial Linux vendors) or relatively loose collaborations of individuals
and organisations (community Linux distributions).&lt;/p&gt;
&lt;p&gt;Modern mobile platforms are generally in a better position than desktop
operating systems, mostly by virtue of being newer, and hence defined after
Unicode was better understood. However, the UTF-8 vs UTF-16-LE distinction
for text handling exists even there, thanks to the Java inspired Dalvik VM
in Android (plus the cloud-backed nature of modern smartphones means you're
even &lt;em&gt;more&lt;/em&gt; likely to be encounter files from multiple machines when working
on a mobile device).&lt;/p&gt;&lt;/div&gt;</description><category>python</category><guid>http://www.curiousefficiency.org/posts/2014/08/multilingual-programming.html</guid><pubDate>Sun, 24 Aug 2014 06:16:15 GMT</pubDate></item><item><title>Why Python 4.0 won't be like Python 3.0</title><link>http://www.curiousefficiency.org/posts/2014/08/python-4000.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;div&gt;&lt;p&gt;Newcomers to python-ideas occasionally make reference to the idea of
"Python 4000" when proposing backwards incompatible changes that don't
offer a clear migration path from currently legal Python 3 code. After all,
we allowed that kind of change for Python 3.0, so why wouldn't we allow it
for Python 4.0?&lt;/p&gt;
&lt;p&gt;I've heard that question enough times now (including the more concerned
phrasing "You made a big backwards compatibility break once, how do I know
you won't do it again?"), that I figured I'd record my answer here, so I'd
be able to refer people back to it in the future.&lt;/p&gt;
&lt;h2&gt;What are the current expectations for Python 4.0?&lt;/h2&gt;
&lt;p&gt;My current expectation is that Python 4.0 will merely be "the release that
comes after Python 3.9". That's it. No profound changes to the language,
no major backwards compatibility breaks - going from Python 3.9 to 4.0
should be as uneventful as going from Python 3.3 to 3.4 (or from 2.6 to 2.7).
I even expect the stable Application Binary Interface (as first defined in
&lt;a href="http://www.python.org/dev/peps/pep-0384/"&gt;PEP 384&lt;/a&gt;) to be preserved across
the boundary.&lt;/p&gt;
&lt;p&gt;At the current rate of language feature releases (roughly every 18 months),
that means we would likely see Python 4.0 some time in 2023, rather than
seeing Python 3.10.&lt;/p&gt;
&lt;h2&gt;So how will Python continue to evolve?&lt;/h2&gt;
&lt;p&gt;First and foremost, nothing has changed about the Python Enhancement Proposal
process - backwards compatible changes are still proposed all the time, with
new modules (like &lt;code&gt;asyncio&lt;/code&gt;) and language features (like &lt;code&gt;yield from&lt;/code&gt;) being
added to enhance the capabilities available to Python applications. As time
goes by, Python 3 will continue to pull further ahead of Python 2 in terms
of the capabilities it offers by default, even if Python 2 users have access
to equivalent capabilities through third party modules or backports from
Python 3.&lt;/p&gt;
&lt;p&gt;Competing interpreter implementations and extensions will also continue to
explore different ways of enhancing Python, including PyPy's exploration of
JIT-compiler generation and software transactional memory, and the
scientific and data analysis community's exploration of array oriented
programming that takes full advantage of the vectorisation capabilities
offered by modern CPUs and GPUs. Integration with other virtual machine
runtimes (like the JVM and CLR) is also expected to improve with time,
especially as the inroads Python is making in the education sector are likely
to make it ever more popular as an embedded scripting language in larger
applications running in those environments.&lt;/p&gt;
&lt;p&gt;For backwards incompatible changes,
&lt;a href="http://www.python.org/dev/peps/pep-0387/"&gt;PEP 387&lt;/a&gt; provides a reasonable
overview of the approach that was used for years in the Python 2 series, and
still applies today: if a feature is identified as being excessively
problematic, then it may be deprecated and eventually removed.&lt;/p&gt;
&lt;p&gt;However, a number of other changes have been made to the development and
release process that make it less likely that such deprecations will be
needed within the Python 3 series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the greater emphasis on the Python Package Index, as indicated by the
  collaboration between the CPython core development team and the Python
  Packaging Authority, as well as the bundling of the &lt;code&gt;pip&lt;/code&gt; installer with
  Python 3.4+, reduces the pressure to add modules to the standard library
  before they're sufficiently stable to accommodate the relatively slow
  language update cycle&lt;/li&gt;
&lt;li&gt;the "provisional API" concept (introduced in
  &lt;a href="http://www.python.org/dev/peps/pep-0411/"&gt;PEP 411&lt;/a&gt;) makes it possible to
  apply a "settling in" period to libraries and APIs that are judged likely
  to benefit from broader feedback before offering the standard backwards
  compatibility guarantees&lt;/li&gt;
&lt;li&gt;a lot of accumulated legacy behaviour really was cleared out in the Python
  3 transition, and the requirements for new additions to Python and the
  standard library are &lt;em&gt;much&lt;/em&gt; stricter now than they were in the Python 1.x
  and Python 2.x days&lt;/li&gt;
&lt;li&gt;the widespread development of "single source" Python 2/3 libraries and
  frameworks strongly encourages the use of "documented deprecation" in
  Python 3, even when features are replaced with newer, preferred,
  alternatives. In these cases, a deprecation notice is placed in the
  documentation, suggesting the approach that is preferred for new code,
  but no programmatic deprecation warning is added. This allows existing
  code, including code supporting both Python 2 and Python 3, to be left
  unchanged (at the expense of new users potentially having slightly more
  to learn when tasked with maintaining existing code bases).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;From (mostly) English to all written languages&lt;/h2&gt;
&lt;p&gt;It's also worth noting that Python 3 wasn't expected to be as disruptive as
it turned out to be. Of all the backwards incompatible changes in Python 3,
many of the serious barriers to migration can be laid at the feet of one
little bullet point in
&lt;a href="http://www.python.org/dev/peps/pep-3100/#atomic-types"&gt;PEP 3100&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Make all strings be Unicode, and have a separate bytes() type. The new
  string type will be called 'str'.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PEP 3100 was the home for Python 3 changes that were considered sufficiently
non-controversial that no separate PEP was considered necessary. The reason
this particular change was considered non-controversial was because our
experience with Python 2 had shown that the authors of web and GUI frameworks
were right: dealing sensibly with Unicode as an &lt;em&gt;application&lt;/em&gt; developer
means ensuring all text data is converted from binary as close to the system
boundary as possible, manipulated as text, and then converted back to binary
for output purposes.&lt;/p&gt;
&lt;p&gt;Unfortunately, Python 2 doesn't encourage developers to write programs that
way - it blurs the boundaries between binary data and text extensively, and
makes it difficult for developers to keep the two separate in their heads,
let alone in their code. So web and GUI framework authors have to tell their
Python 2 users "always use Unicode text. If you don't, you may suffer from
obscure and hard to track down bugs when dealing with Unicode input".&lt;/p&gt;
&lt;p&gt;Python 3 is different: it imposes a much greater separation between the
"binary domain" and the "text domain", making it easier to write normal
application code, while making it a bit harder to write code that works
with system boundaries where the distinction between binary and text data
can be substantially less clear. I've written in more detail
&lt;a href="http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#what-actually-changed-in-the-text-model-between-python-2-and-python-3"&gt;elsewhere&lt;/a&gt;
regarding what actually changed in the text model between Python 2 and
Python 3.&lt;/p&gt;
&lt;p&gt;This revolution in Python's Unicode support is taking place against a larger
background migration of computational text manipulation from the English-only
&lt;a href="https://en.wikipedia.org/wiki/ASCII"&gt;ASCII&lt;/a&gt; (officially defined in 1963),
through the complexity of the "binary data + encoding declaration" model
(including the &lt;a href="https://en.wikipedia.org/wiki/Locale"&gt;C/POSIX locale&lt;/a&gt; and
&lt;a href="https://en.wikipedia.org/wiki/Windows_code_page"&gt;Windows code page&lt;/a&gt;
systems introduced in the late 1980's) and the initial 16-bit only
version of the &lt;a href="https://en.wikipedia.org/wiki/Unicode"&gt;Unicode standard&lt;/a&gt;
(released in 1991) to the relatively comprehensive modern Unicode code point
system (first defined in 1996, with new major updates released every few years).&lt;/p&gt;
&lt;p&gt;Why mention this point? Because this switch to "Unicode by default" is the
most disruptive of the backwards incompatible changes in Python 3 and unlike
the others (which were more language specific), it is one small part of a
much larger industry wide change in how text data is represented and
manipulated. With the language specific issues cleared out by the Python 3
transition, a much higher barrier to entry for new language features compared
to the early days of Python and no other industry wide migrations on the
scale of switching from "binary data with an encoding" to Unicode for text
modelling currently in progress, I can't see any kind of change coming up
that would require a Python 3 style backwards compatibility break and
parallel support period. Instead, I expect we'll be able to accommodate any
future language evolution within the normal change management processes, and
any proposal that can't be handled that way will just get rejected as
imposing an unacceptably high cost on the community and the core development
team.&lt;/p&gt;&lt;/div&gt;</description><category>python</category><guid>http://www.curiousefficiency.org/posts/2014/08/python-4000.html</guid><pubDate>Sun, 17 Aug 2014 05:30:55 GMT</pubDate></item><item><title>Some Suggestions for Teaching Python</title><link>http://www.curiousefficiency.org/posts/2014/08/python-teaching-suggestions.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;div&gt;&lt;p&gt;I recently had the chance to attend a Software Carpentry bootcamp at the
University of Queensland (as a teaching assistant), as well as seeing a
presentation from one of UQ's tutors at PyCon Australia 2014.&lt;/p&gt;
&lt;p&gt;While many of the issues they encountered were inherent in the complexity
of teaching programming, a few seemed like things that could be avoided.&lt;/p&gt;
&lt;h2&gt;Getting floating point results from integer division&lt;/h2&gt;
&lt;p&gt;In Python 2, integer division copies C in truncating the answer by default:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;    &lt;span class="nv"&gt;$ &lt;/span&gt;python -c &lt;span class="s2"&gt;"print(3/4)"&lt;/span&gt;
    0
&lt;/pre&gt;


&lt;p&gt;Promoting to floating point requires type coercion, a command line flag
or a future import:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;    &lt;span class="nv"&gt;$ &lt;/span&gt;python -c &lt;span class="s2"&gt;"print(float(3)/4)"&lt;/span&gt;
    0.75
    &lt;span class="nv"&gt;$ &lt;/span&gt;python -Qnew -c &lt;span class="s2"&gt;"print(3/4)"&lt;/span&gt;
    0.75
    &lt;span class="nv"&gt;$ &lt;/span&gt;python -c &lt;span class="s2"&gt;"from __future__ import division; print(3/4)"&lt;/span&gt;
    0.75
&lt;/pre&gt;


&lt;p&gt;Python 3 just does the right thing by default, so one way to avoid the
problem entirely is to teach Python 3 instead of Python 2:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;    &lt;span class="nv"&gt;$ &lt;/span&gt;python3 -c &lt;span class="s2"&gt;"print(3/4)"&lt;/span&gt;
    0.75
&lt;/pre&gt;


&lt;p&gt;(In both Python 2 and 3, the &lt;code&gt;//&lt;/code&gt; floor division operator explicitly
requests truncating division when it is desired)&lt;/p&gt;
&lt;h2&gt;Common Python 2/3 syntax for printing values&lt;/h2&gt;
&lt;p&gt;I've been using Python 2 and 3 in parallel for more than 8 years now (while
Python 3.0 was released in 2008, the project started in earnest a couple
of years earlier than that, while Python 2.5 was still in development).&lt;/p&gt;
&lt;p&gt;One essential trick I have learned in order to make regularly switching back
and forth feasible is to limit myself to the common print syntax that works
the same in both versions: passing a single argument surrounded by
parentheses.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;python -c &lt;span class="s1"&gt;'print("Hello world!")'&lt;/span&gt;
Hello world!
&lt;span class="nv"&gt;$ &lt;/span&gt;python3 -c &lt;span class="s1"&gt;'print("Hello world!")'&lt;/span&gt;
Hello world!
&lt;/pre&gt;


&lt;p&gt;If I need to pass multiple arguments, I'll use string formatting, rather
than the implicit concatenation feature.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;python -c &lt;span class="s1"&gt;'print("{} {}{}".format("Hello", "world", "!"))'&lt;/span&gt;
Hello world!
&lt;span class="nv"&gt;$ &lt;/span&gt;python3 -c &lt;span class="s1"&gt;'print("{} {}{}".format("Hello", "world", "!"))'&lt;/span&gt;
Hello world!
&lt;/pre&gt;


&lt;p&gt;Rather than doing this, the Software Carpentry material that was used at the
bootcamp I attended used the legacy Python 2 only &lt;code&gt;print&lt;/code&gt; syntax extensively,
causing examples that otherwise would have worked fine in either version to
fail for students that happened to be running Python 3. Adopting the shared
syntax for printing values could be enough to make the course largely
version independent.&lt;/p&gt;
&lt;h2&gt;Distinguishing between returning and printing values&lt;/h2&gt;
&lt;p&gt;One problem noted both at the bootcamp and by presenters at PyCon Australia
was the challenge of teaching students the difference between printing and
returning values. The problem is the "Print" part of the Read-Eval-Print-Loop
provided by Python's interactive interpreter:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_arg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;return_arg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;print_arg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return_arg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;There's no obvious difference in output at the interactive prompt, especially
for types like numbers where the results of &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;repr&lt;/code&gt; are the same.
Even when they're different, those differences may not be obvious to a
student:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;print_arg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello world"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Hello&lt;/span&gt; &lt;span class="n"&gt;world&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return_arg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello world"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;'Hello world'&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;While I don't have a definitive answer for this one, an experiment that seems
worth trying to me is to teach students how to replace &lt;code&gt;sys.displayhook&lt;/code&gt;. In
particular, I suggest demonstrating the following change, and seeing if it
helps explain the difference between printing output for display to the user
and returning values for further processing:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;new_displayhook&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;         &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-&amp;gt; {!r}"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;displayhook&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_displayhook&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;print_arg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;return_arg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Understanding the difference between printing and returning is essential to
learning to use functions effectively, and tweaking the display of results
this way may help make the difference more obvious.&lt;/p&gt;
&lt;h2&gt;Addendum: IPython (including IPython Notebook)&lt;/h2&gt;
&lt;p&gt;The initial examples above focused on the standard CPython runtime, include
the default interactive interpreter. The IPython interactive interpreter,
including the IPython Notebook, has a couple of interesting differences in
behaviour that are relevant to the above comments.&lt;/p&gt;
&lt;p&gt;Firstly, it &lt;em&gt;does&lt;/em&gt; display return values and printed values differently,
prefacing &lt;em&gt;results&lt;/em&gt; with an output reference number:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt;

&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Secondly, it has an optional "autocall" feature that allows a user to tell
IPython to automatically add the missing parentheses to a function call if
the user leaves them out:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ipython3 --autocall&lt;span class="o"&gt;=&lt;/span&gt;1 -c &lt;span class="s2"&gt;"print 10"&lt;/span&gt;
-&amp;gt; print&lt;span class="o"&gt;(&lt;/span&gt;10&lt;span class="o"&gt;)&lt;/span&gt;
10
&lt;/pre&gt;


&lt;p&gt;This is a general purpose feature that allows users to make their IPython
sessions behave more like languages that don't have first class functions
(most notably, IPython's autocall feature closely resembles MATLAB's
"command syntax" notation for calling functions).&lt;/p&gt;
&lt;p&gt;It also has the side effect that users that use IPython, have autocall
enabled, and don't use any of the more esoteric quirks of the Python 2
&lt;code&gt;print&lt;/code&gt; statement (like stream redirection or suppressing the trailing
newline) may not even notice that &lt;code&gt;print&lt;/code&gt; became an ordinary builtin in
Python 3.&lt;/p&gt;&lt;/div&gt;</description><category>python</category><guid>http://www.curiousefficiency.org/posts/2014/08/python-teaching-suggestions.html</guid><pubDate>Fri, 08 Aug 2014 12:55:26 GMT</pubDate></item><item><title>Change the Future - one small slice of PyCon US 2013</title><link>http://www.curiousefficiency.org/posts/2013/03/change-future-one-small-slice-of-pycon.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;div dir="ltr" style="text-align: left;"&gt;I'm currently kicking back in Red Hat's Mountain View office (I normally work from the Brisbane office in Australia) after a lovely lunch with some of the local Red Hatters, unwinding a bit and reflecting on an absolutely amazing week at PyCon US 2013 just down the road in Santa Clara.&lt;br&gt;&lt;br&gt;For me, it started last Wednesday with the &lt;a href="http://python-notes.curiousefficiency.org/en/latest/conferences/pyconus2013/20130313-language-summit.html"&gt;Python Language Summit&lt;/a&gt; , an at-least-annual-sometimes-biannual get together of the developers of several major Python implementations, including CPython (the reference interpreter), PyPy, Jython and IronPython. Even with a full day, there were still a lot of interesting topics we didn't get to and will be thrashing out on the mailing lists as usual. However, good progress was made on a few of the more controversial items, and there are definitely exciting developments in store for Python 3.4 (due in early 2014, probably shortly after PyCon in Montreal if past history is anything to go by).&lt;br&gt;&lt;br&gt;Thursday was a real eye-opener for me. While I did have to duck out at one point for a meeting with a couple of the other CPython developers, I spent most of it helping out at the second of the &lt;a href="https://us.pycon.org/2013/events/letslearnpython/"&gt;Young Coders&lt;/a&gt; tutorials run by &lt;a href="http://therealkatie.net/blog/2013/mar/19/pycon-2013-young-coders/"&gt;Katie Cunningham&lt;/a&gt; and &lt;a href="http://mechanicalgirl.com/post/young-coders-learning-python-pycon-2013/"&gt;Barbara Shaurette&lt;/a&gt;. These tutorials were conducted using Raspberry Pi's with rented peripherals, and the kids attending received both the Pi they were using as well as a couple of introductory programming books.&lt;br&gt;&lt;br&gt;Watching the class, and listening to Katie's and Barbara's feedback on what they need from us in the core substantially &lt;a href="http://mail.python.org/pipermail/python-dev/2013-March/124872.html"&gt;changed my perspective&lt;/a&gt; on what IDLE can (and, I think, should) become. Roger Serwy (the creator of IdleX, a version of IDLE with various improvements) has now been granted access to the CPython repo to streamline the process of fixing the reference implementation, and we're working on plans to make the behaviour of IDLE more consistent across all currently supported Python versions (including Python 2.7). (Some aspects of this, especially Roger's involvement, are similar to what happened years ago for Python 2.3 when Kurt B. Kaiser, the PSF's treasurer, shepherded the reintegration of the &lt;a href="http://idlefork.sourceforge.net/"&gt;IDLEfork&lt;/a&gt; project and its major enhancements to IDLE back into the reference IDLE implementation in the Python standard library). &lt;br&gt;&lt;br&gt;Friday saw the start of the conference proper, with inspirational keynotes from &lt;a href="http://www.pyvideo.org/video/1848/opening-statements"&gt;Jesse Noller &lt;/a&gt;(conference chair and PSF board member) on helping to change the future by changing the way we introduce the next generation to the computers that are now an ever-present aspect of our lives, and from &lt;a href="http://www.pyvideo.org/video/1668/keynote-2"&gt;Eben Upton&lt;/a&gt; (co-founder of the Raspberry Pi foundation), on how the Pi came to be the educational project it is today, and some thoughts on how it might evolve into the future.&lt;br&gt;&lt;br&gt;Jesse's keynote included the announcement that every attendee (all 2500 of them) would be receiving a free Raspberry Pi, and that any Pi's that attendees didn't want to claim would be redistributed to various educational groups and programs. Not only that, but Jesse also announced &lt;a href="http://raspberry.io/"&gt;http://raspberry.io/&lt;/a&gt;, a new site for sharing Raspberry Pi based projects and resources, as well as a "Rasberry Pi Hack Lab" running for the duration of the conference, where attendees could hook their Pi's up to a keyboard and monitor, as well as experiment with various bits and pieces of electronics donated by one of the conference sponsors. &lt;a href="http://www.mechanicalcat.net/richard/log/Python/How_awesome_was_PyCon"&gt;Richard Jones&lt;/a&gt; also stepped up to run some additional short introductory PyGame tutorials in the lab (he had run a full 3 hour session on PyGame as part of the paid tutorials on the Wednesday and Thursday prior to the conference).&lt;br&gt;&lt;br&gt;One key personal theme for the conference revolved around the fact that I've volunteered to be Guido's delegate in making the final decisions on how we reshape Python's packaging ecosystem in the lead up to the Python 3.4 release. I'll be writing quite a bit more on that topic over the coming weeks, so here I'll just note that it started with proposing some changes to the Python Enhancement Proposal process at the language summit on the Wednesday, continued through the announcement of the coming setuptools/distribute merger on Thursday, the "packaging and distribution" mini-summit I organised for developers on the Friday night, the "Directions in Packaging" &lt;a href="https://us.pycon.org/2013/schedule/presentation/34/"&gt;Q&amp;amp;A panel&lt;/a&gt; we conducted on the Saturday afternoon, some wonderful discussions with Simeon Franklin &lt;a href="http://simeonfranklin.com/blog/2013/mar/17/my-pycon-2013-poster/"&gt;on his blog&lt;/a&gt; regarding the way the current packaging and distributions issues detract from Python's beginner friendliness and on into various interesting discussions, proposals and development at the sprints in the days following the conference.&lt;br&gt;&lt;br&gt;Unfortunately, I didn't actually get to meet Simeon in person, even though I had flagged his poster as one I really wanted to go see during the poster session. Instead, I spent that time at the Red Hat booth in the PyCon Jobs Fair.  The Jobs Fair is a wonderful idea from the conference organisers that, along with the Expo Hall, recognises the multi-role nature of PyCon: as a community conference for sharing and learning (through the summits, scheduled talks, lightning talks, poster session, open spaces, paid tutorials, Young Coders sessions, Raspberry Pi hack lab, and sprints), as a way for sponsors to advertise their services to developers (through the Expo Hall and sponsor tutorials) and as a way for sponsors to recruit new developers (through the Jobs Fair). PyCon has long involved elements of all of these things (albeit perhaps not at the scale achieved this year), but having the separate Expo Hall and Jobs Fair helps keep sales and recruitment activity from bleeding into the community parts of the conference, while still giving sponsors a suitable opportunity to connect with the development community.&lt;br&gt;&lt;br&gt;Both at the Jobs Fair and during the rest of the conference, I was explaining to anyone that was willing to listen what I see as Red Hat's role in bridging the vast gulf between open source software enthusiasts (professionals and amateurs alike) and people for whom software is merely a tool that either helps (hopefully) or hinders (unfortunately far too often) them in spending time on their actual job/project/hobby/etc.&lt;br&gt;&lt;br&gt;I also spent a lot of time talking to people about my actual day job. I'm the development lead for &lt;a href="http://beaker-project.org/"&gt;one of the test systems&lt;/a&gt; at Red Hat, and while it is very good at what it does (full stack integration testing from hardware, through the OS and up into application software), it also needs to integrate well with other systems like autotest and OpenStack if we're going to avoid pointlessly reinventing a lot of very complicated wheels. Learning more about what those projects are currently capable of makes it easier for me to prioritize the things we work on, and make suitable choices about Beaker's overall architecture.&lt;br&gt;&lt;br&gt;At the sprints, in addition to working on CPython and some packaging related questions, I also took the opportunity to catch up with the Mailman 3 developers - the open source world needs an email/web forum gateway that at least isn't actively awful, and the combination of Mailman 3 with the hyperkitty archiver is shaping up to be positively wonderful.&lt;br&gt;&lt;br&gt;&lt;br&gt;I didn't spend the &lt;i&gt;entire&lt;/i&gt; conference weekend talking to people - I actually got to go see a few talks as well. All of the talks I attended were excellent, but some particular personal highlights were &lt;a href="https://us.pycon.org/2013/schedule/presentation/88/"&gt;Mike Bayer's deep dive&lt;/a&gt; into SQL Alchemy's session behaviour, &lt;a href="https://us.pycon.org/2013/schedule/presentation/104/"&gt;the panel on&lt;/a&gt; the &lt;a href="http://bostonpythonworkshop.com/"&gt;Boston Python Workshop&lt;/a&gt; and a number of other BPW inspired education and outreach events, &lt;a href="https://us.pycon.org/2013/schedule/presentation/98/"&gt;Mel Chua's whirlwind tour&lt;/a&gt; of educational psychology,  &lt;a href="https://us.pycon.org/2013/schedule/presentation/144/"&gt;Lynn Root's educational projects&lt;/a&gt; for new coders (with &lt;a href="http://newcoder.io/"&gt;accompanying website&lt;/a&gt;), &lt;a href="https://us.pycon.org/2013/schedule/presentation/95/"&gt;Dave Malcolm's follow-up&lt;/a&gt; on his efforts with static analysis of all of the CPython extensions in Fedora, and &lt;a href="https://us.pycon.org/2013/schedule/presentation/222/"&gt;Dave Beazley's ventures&lt;/a&gt; into automated home manufacturing of wooden toys (and destruction of laptop hard drives). There were plenty of other talks that looked interesting but I unfortunately didn't get to (one of the few downsides of having so many impromptu hallway conversations). All the PyCon US 2013 talks should be showing up on &lt;a href="http://www.pyvideo.org/category/33/pycon-us-2013"&gt;pyvideo.org&lt;/a&gt; as the presenters give the thumbs up, and the &lt;a href="https://speakerdeck.com/pyconslides/"&gt;presentation slides&lt;/a&gt; are also available, so it's worth trawling through the respective lists for the topics that interest you.&lt;br&gt;&lt;br&gt;In the midst of all that, Van Lindberg (PSF chairman) revealed the first public draft of the &lt;a href="http://preview.python.org/"&gt;redesigned python.org&lt;/a&gt; (I was one of the members of the review committee that selected Project Evolution, RevSys and Divio as the drivers of this initial phase of the redesign process), and also announced the &lt;a href="http://arstechnica.com/information-technology/2013/03/python-wins-trademark-dispute-rival-stops-calling-itself-python/"&gt;successful resolution&lt;/a&gt; of the PSF's trademark dispute in the EU.&lt;br&gt;&lt;br&gt;This was only my second PyCon in North America (I've been to all three Australian PyCons, and attended PyCon India last year) and the first since I joined Red Hat. Meeting old friends from around the world, meeting other Pythonistas that I only knew by reputation or through Twitter and email, and meeting fellow Red Hatters that I had previously only met through IRC and email was a huge amount of fun. Attending the PyLadies charity auction, visiting the Computer History Museum with Guido van Rossum, Ned Deily and Dwayne Litzenberger (from Dropbox), chatting with Stephen Turnbull about promoting the adoption of open source and open source development practices in Japan, and getting to tour a small part of the Googleplex were just a few of the interesting bonus events from the week (and now I have a few days vacation to do the full tourist thing here in SFO).&lt;br&gt;&lt;br&gt;I'm still on an adrenaline high, and there are at least a dozen different reasons why. If everything above isn't enough, there were a few other exciting developments happening behind the scenes that I can't go into yet. Fortunately, the details of those should become public over the next few weeks so I won't need to contain myself too long.&lt;br&gt;&lt;br&gt;This week was intense, but &lt;i&gt;awesome&lt;/i&gt;. All the organisers, volunteers and sponsors that played a part in bringing it together should be proud :)&lt;/div&gt;</description><category>python</category><guid>http://www.curiousefficiency.org/posts/2013/03/change-future-one-small-slice-of-pycon.html</guid><pubDate>Fri, 22 Mar 2013 01:38:00 GMT</pubDate></item><item><title>Python Language Summit - PyCon US 2013</title><link>http://www.curiousefficiency.org/posts/2013/03/python-language-summit-pycon-us-2013.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;div dir="ltr" style="text-align: left;"&gt;My notes from the PyCon US 2013 Python Language Summit &lt;a href="http://python-notes.curiousefficiency.org/en/latest/conferences/pyconus2013/20130313-language-summit.html"&gt;are up on ReadTheDocs.&lt;/a&gt;&lt;br&gt;&lt;br&gt;Courtesy of Vinay Sajip, I've also found out how to integrate DISQUS comments into my Python Notes pages, so feedback can happen directly over there :)&lt;/div&gt;</description><category>python</category><category>tech</category><guid>http://www.curiousefficiency.org/posts/2013/03/python-language-summit-pycon-us-2013.html</guid><pubDate>Thu, 14 Mar 2013 14:28:00 GMT</pubDate></item><item><title>PyCon India 2012</title><link>http://www.curiousefficiency.org/posts/2012/11/pycon-india-2012.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;p&gt;Inspired by Noufal Ibrahim's &lt;a href="http://www.devworx.in/features/the-state-of-python-in-india-136921.html"&gt;recent article&lt;/a&gt; on the general state of the Python community in India, I've finally written this belated report on my recent India trip :)&lt;br&gt;&lt;br&gt;At the end of October, I had the good fortune to attend PyCon India 2012 in Bangalore. Sankarshan Mukhopadhyay (from Red Hat's Pune office) suggested I submit some talk proposals a few months earlier, and I was able to combine a trip to attend the conference with visits to the Red Hat offices in Bangalore and Pune. It's always good to finally get to associate IRC nicks and email addresses with people that you've actually met in person! While Sankarshan unfortunately wasn't able to make it to the conference himself, I did get to meet him when I visited Pune, and Kushal Das and Ramakrishna Reddy (also fellow Red Hatters) took great care of me while I was over there (including a weekend trip out from Pune to see the Ajanta and Ellora caves - well worth the visit, especially if you're from somewhere like Australia with no human-built structures more than a couple of hundred years old!)&lt;br&gt;&lt;br&gt;While I wasn't one of the keynote speakers (David Mertz gave the &lt;a href="https://www.youtube.com/watch?v=EJseJV6RLUg"&gt;Saturday keynote&lt;/a&gt;, and Jacob Kaplan-Moss gave an excellent &lt;a href="https://www.youtube.com/watch?v=2ydxV6gYXL4"&gt;"State of the Python Web"&lt;/a&gt; keynote on Sunday), I did give a couple of talks - one on the &lt;a href="https://www.youtube.com/watch?v=SqidFaoNmP8&amp;amp;feature=plcp"&gt;new features in the recent Python 3.3 release&lt;/a&gt;, along with a longer version of the Path Dependent Development talk that I had previously presented at PyCon AU in August. Both seemed to go over reasonably well, and people liked the way Ryan Kelly's "playitagainsam" and "playitagainsam-js" tools allowed me to embed some demonstration code directly in the HTML5 presentation for the Python 3.3 talk.&lt;br&gt;&lt;br&gt;Aside from giving those two talks, this was a rather different conference for me, as I spent a &lt;i&gt;lot&lt;/i&gt; more time in the hallway chatting with people than I have at other Python conferences. It was interesting to see quite a few folks making the assumption that because I'm a core developer, I must be an expert on all things Python, when I'm really a relative novice in many specific application areas. Fortunately, I was able to pass the many web technology related questions on to Jacob, so people were still able to get good answers to their questions, even when I couldn't supply them myself. I also got to hear about some interesting projects people are working on, such as an IVRS utility for mothers to call to find out about required and recommended vaccinations for their newborn children (I alluded to this previously in &lt;a href="http://www.curiousefficiency.org/2012/10/pythons-future-global-perspective.html"&gt;my post&lt;/a&gt; about my perspective on Python's future prospects).&lt;br&gt;&lt;br&gt;One thing unfortunately missing from the PyCon India schedule was the target experience level for the talks, so I did end up going to a couple of talks that, while interesting and well presented introductions to the topic, didn't actually tell me anything I didn't already know. Avoiding any chance of that outcome is one of the reasons I really like attending "How we are using Python" style talks, and my favourite talk of the conference (aside from Jacob's keynote) was actually the one from Noufal Ibrahim and Anand Chitipothu on &lt;a href="https://www.youtube.com/watch?v=pDlOpMDwb-Q&amp;amp;feature=plcp"&gt;rewriting the Wayback Machine's archiving system&lt;/a&gt; (The other major reason I like attending such talks is that knowing I played a part, however small, in making these things possible is just plain &lt;i&gt;cool&lt;/i&gt;).&lt;br&gt;&lt;br&gt;While the volunteers involved put in a lot of effort and the conference was well attended and well worth attending, the A/V handling at the conference does still have room for improvement, as the videos linked above indicate. I've sent a few ideas to the organisers about reaching out to the PSF board for assistance and suggestions on that front. Hopefully they'll look into that a bit more for next year, as I think producing high quality talk recordings can act as excellent advertising for tech conferences in subsequent years, but doing that effectively requires a lot of preparation work both before and during the conference. There are some good resources for this now in the Python community at least in Australia and the US, so I'm hopeful that the PSF will be able to play a part in transferring that knowledge and experience to other parts of the world and we'll start seeing more and more Python conferences with recordings of a similar calibre to those from PyCon US and PyCon AU.&lt;br&gt;&lt;/p&gt;</description><category>python</category><category>travel</category><guid>http://www.curiousefficiency.org/posts/2012/11/pycon-india-2012.html</guid><pubDate>Wed, 21 Nov 2012 06:34:00 GMT</pubDate></item><item><title>Python's Future: A Global Perspective</title><link>http://www.curiousefficiency.org/posts/2012/10/pythons-future-global-perspective.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;div dir="ltr" style="text-align: left;"&gt;&lt;h3 style="text-align: left;"&gt;Is Python's future currently at risk? (TLDR: No)&lt;/h3&gt;&lt;br&gt;Calvin Spealman recently &lt;a href="http://www.ironfroggy.com/software/i-am-worried-about-the-future-of-python"&gt;posted his thoughts&lt;/a&gt; on various aspects of where he sees computing in general heading, and his concerns about where Python may fit in that future.&lt;br&gt;&lt;br&gt;I think his concerns are somewhat valid as far as specific market segments go, but I think they're overstating the case when it comes to "the future of Python", because I think his article takes a very narrow view of the computing field.&lt;br&gt;&lt;br&gt;Smartphones and tablets are the new desktop (although the desktop won't go away, it will become limited to power users with demands for precision control and complex workflows). Python has long been relatively weak on the desktop when it comes to redistributing applications, due to the need to get the interpreter installed before it can be used. Microsoft's redistribution restrictions on their C runtime has made this all the more difficult when it comes to Windows. &lt;br&gt;&lt;br&gt;We also made a fairly major misstep when we failed to appropriately advertise the addition of directory and zipfile execution support in Python 2.6 (bundle your code with all its dependencies except Python into a directory or zipfile and add a &lt;span&gt;__main__.py&lt;/span&gt; file and the Python interpreter will execute it as if it was a script. With a zip file, you can even add a shebang line to the front and flag it it as executable and a POSIX shell will pass it to Python automatically if you run it directly. I haven't tried it, but the &lt;span&gt;py&lt;/span&gt; launcher shipped with 3.3 should also handle such files). While we later went back and added the &lt;a href="http://docs.python.org/whatsnew/2.6#other-language-changes"&gt;appropriate notice&lt;/a&gt; to the What's New in Python 2.6 documentation, and updated the &lt;a href="http://docs.python.org/using/cmdline.html#interface-options"&gt;command line guide&lt;/a&gt; in the documentation, this capability still isn't widely known.&lt;br&gt;&lt;br&gt;The complaints about dynamic language overhead on mobile devices  don't hold much water for me. Smartphones now are more powerful than  desktops were less than a decade ago, and Mozilla's Boot2Gecko project holds a lot of potential. While battery technology doesn't advance as fast as computing technology, Moore's Law is leveraged in the mobile space to allow more to be done with less power, reproducing the desktop (and server!) trajectories where dynamic languages were initially derided as too slow, until the hardware caught up to get them to the point of being "fast enough".&lt;br&gt;&lt;br&gt;However, Python's real strengths have long been server side technology, software development by non-programmers and as an embedded scripting engine for trusted plugins (rather than those that need to be strictly isolated from, for example, a core game engine or the host OS). And in those areas, it's still powering ahead.&lt;br&gt;&lt;br&gt;&lt;h3 style="text-align: left;"&gt;Widespread adoption requires being taken for granted&lt;/h3&gt;Install a Linux distro. Which dynamic language interpreters are pre-installed? If you're using Debian or Fedora, it will be Python and Perl. The presence of those two can pretty much be taken for granted. Ruby probably won't be there, and a standalone Javascript interpreter certainly won't be.&lt;br&gt;&lt;br&gt;Apple have expressed their support for Python by building tools that rely on it (with, as far as I know, Python being the only dynamic language interpreter shipped as part of Mac OS X. &lt;i&gt;Update: I'm told Apple ship Perl and Ruby as well&lt;/i&gt;), and Microsoft ship their Python Tools for Visual Studio bundle. Google, of course, famously chose Python as the only dynamic language supported on their App Engine platform (and they currently employ Guido van Rossum and a number of other Python core developers).&lt;br&gt;&lt;br&gt;gcc and gdb both let you write plugins, and your language choices are C/C++ or Python (plus Lisp in the gcc case). Many other infrastructure level tools are going the same way. Fedora's infrastructure is almost entirely written in Python, as is OpenStack.&lt;br&gt;&lt;br&gt;If you're into multimedia development, Python will be a core part of your toolset, and Python is the key open source competitor to proprietary toolsets in the scientific community. The Natural Language Toolkit is a hugely powerful resource for many data mining applications, and Python is entwined deeply into the core of the financial sector as well.&lt;br&gt;&lt;br&gt;Also, just as many years ago a lot of formal education program switched from C and C++ (or Pascal or Ada, etc) to Java for introductory programming courses, many are now switching to Python, pushing Java into the role of an enterprise language used only for large and complex applications where the development overhead can be justified to some degree. Businesses are getting to the point where they can choose Python as part of their technology base while being assured of a future pool of recruits that already know the language.&lt;br&gt;&lt;br&gt;Informal education programs are also favouring Python as the first "real world" application language that people are introduced to. OLPC chose Python, as did RaspberryPI. Readability counts.&lt;br&gt;&lt;br&gt;The Python Africa Tour has attracted quite a bit of interest, and I believe Africa plays host to its first PyCon later this year (in South Africa). Every other continent has now hosted multiple PyCon's each year in different countries and regions.&lt;br&gt;&lt;br&gt;&lt;h3 style="text-align: left;"&gt;Only one kind of client&lt;/h3&gt;Things are substantially more competitive on the web service  front, with Rails and Django going head-to-head, and Node.js attempting to play the "you can use the same language on the frontend and the backend!" card.&lt;br&gt;&lt;br&gt;As far as Node.js goes, I'm firmly convinced that if Node.js was going to be a hugely popular server side  framework, Twisted would have taken over the world by now. Callback  based programming is just plain &lt;i&gt;hard&lt;/i&gt; for most humans to wrap  their heads around (often even harder than threaded programming) - hence  the popularity of &lt;span&gt;greenlets&lt;/span&gt; and &lt;span&gt;gevent&lt;/span&gt; in the Python world, which permit the use of asynchronous IO capabilities with a threading-like programming style. The  ongoing efforts around tweaking generator syntax and capabilities in Python core development could legitimately be summarised as "make it possible to write Twisted code in a way  that doesn't hurt people's brains quite so much and without relying on the magical stack-switching assembly code needed for greenlets".&lt;br&gt;&lt;br&gt;In this space, Python's strength really lies in its ability to step away from traditional web technologies. Want to talk over a serial port to a piece of lab equipment or radio modem? Sure, we can do that. Want to talk to telco gear through a custom C extension? Sure, we have a wide range of tools to support that, too, along with some great Asterisk bindings. Python also has many web framework options, like Pyramid and Flask, that let you be more easily be selective in your choice of components than Django does.&lt;br&gt;&lt;br&gt;This is important, because I just spent the past weekend here at PyCon India. While smartphones are popular amongst the largely urban professionals that make up the web development community and those they regularly associate with, they're still only available to a vanishingly small percentage of the global population. Much of the rest of the world doesn't even have access to a desktop computer let alone a smartphone. What they &lt;i&gt;do&lt;/i&gt; have though are ordinary &lt;i&gt;mobile phones&lt;/i&gt; (aka cellphones, for any Americans in the audience).&lt;br&gt;&lt;br&gt;Added to that is the fact that the majority of the world's population is illiterate - they can understand spoken instructions, and are sufficiently numerate to press numbers on a keypad to operate an Interactive Voice Response System, but they won't be operating a smartphone any time soon, even if one was available to them.&lt;br&gt;&lt;br&gt;The interfaces and language capabilities you need to reach *that* audience look nothing like those you can use to reach the smartphone toting crowd.&lt;br&gt;&lt;br&gt;And that's before we even get into the potential long term implications of verbal and tactile interfaces like Siri and &lt;a href="https://www.youtube.com/watch?v=rjPFqkFyrOY"&gt;Baxter&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;h3 style="text-align: left;"&gt;No reason to relax&lt;/h3&gt;All that said, while Python's future is looking very, very bright from where I sit, that's no reason to relax and assume that future is assured. Python is far from perfect, and the same can be said for the ecosystem around us.&lt;br&gt;&lt;br&gt;Jacob's Sunday keynote at PyCon India spoke about the need for Python's web community to work on embracing the real time web, and lowering the barriers to entry to providing network-based realtime interactivity in Python-based web applications. It's likely any such efforts will require an update to the WSGI standards to support a streaming IO component, in addition to the current request/response model.&lt;br&gt;&lt;br&gt;Tools like Kivy, that aim to make it easier to write mobile applications in Python are also an important part of extending Python's reach into areas where it is currently weak.&lt;br&gt;&lt;br&gt;The recent 3.3 release included several elements aimed at making things easier for beginners (especially those on Windows), including improved error messages, an option to modify PATH in the Windows installer and the Python launcher, while the entire Python 3 series is aimed at embracing Unicode as part of the core of the language, allowing it to better reach beyond its original audience of users whose native alphabets could be expressed within the constraints of ASCII or an 8-bit encoding.&lt;br&gt;&lt;br&gt;3.3 also took some of the first steps in improving the "out of the box" packaging dependency management experience, by integrating virtual environment support and namespace packages (along with making empty &lt;span&gt;__init__.py&lt;/span&gt; files optional).&lt;br&gt;&lt;br&gt;Concurrency is a problem where the overall Python ecosystem has many more options than those provided by the CPython interpreter implementation. We do offer plenty of interesting tools, especially for embarrassingly parallel problems that fit nicely into the concurrent.futures execution model. The GIL does cause problems for particular workloads, and switching to Jython or IronPython to take advantage of the free-threaded JVM and CLR implementations isn't always going to be an option. I've written &lt;a href="http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#but-but-surely-fixing-the-gil-is-more-important-than-fixing-unicode"&gt;far more extensively&lt;/a&gt; on that topic, though, so I won't repeat that here.&lt;br&gt;&lt;br&gt;We should also look at ways of making it easier for other languages  to interoperate with Python without an intervening C interface. Perhaps  Python should ship a &lt;span&gt;pycall&lt;/span&gt; script like &lt;a href="https://bitbucket.org/ncoghlan/misc/src/default/pycall"&gt;this one&lt;/a&gt;,  that makes it easy to invoke Python functions directly in a pipeline or  from another application (passing JSON data in via stdin, and receiving  JSON data back via stdout). Conversely, better shell integration is always worth exploring.&lt;br&gt;&lt;br&gt;And, of course, our journey in rebuilding the Unicode infrastructure is ongoing. Python 3.4 is likely to bring improvements in the ability to switch the encoding of a stream "mid-flight", as well as restoring some convenience APIs for the non-Unicode related uses of the encoding and decoding methods in Python 2.&lt;br&gt;&lt;br&gt;So yes, there are plenty of areas where Python can, and should, and probably will, improve. But we shouldn't lose sight of the fact that many of the problems with Python (like binary distribution, dependency management and concurrency) are problems with software development generally, so there's nowhere for people to go that will magically make those issues disappear (or else they come at the price of losing out on many of Python's other advantages, or committing to a particular platform, or some other downside).&lt;br&gt;&lt;br&gt;We're a conservative community by nature - we generally &lt;i&gt;don't like&lt;/i&gt; blazing trails when it comes to language design. Instead, we're happy to let others rush ahead, letting them figure out where the pitfalls are, while we see what we can learn from their experience and integrate into Python's syntax, standard libraries, or the Python Package Index.&lt;/div&gt;</description><category>python</category><guid>http://www.curiousefficiency.org/posts/2012/10/pythons-future-global-perspective.html</guid><pubDate>Mon, 01 Oct 2012 17:58:00 GMT</pubDate></item><item><title>Volunteer developed free-threaded cross platform virtual machines?</title><link>http://www.curiousefficiency.org/posts/2012/07/volunteer-supported-free-threaded-cross.html</link><dc:creator>Nick Coghlan</dc:creator><description>&lt;p&gt;Since writing my &lt;a href="http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html"&gt;Python 3 Q &amp;amp; A&lt;/a&gt;, including &lt;a href="http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#but-but-surely-fixing-the-gil-is-more-important-than-fixing-unicode"&gt;some thoughts&lt;/a&gt; on why the CPython GIL isn't likely to go away any time soon, I've been pondering the question of free-threaded cross platform virtual machines for dynamic languages. Specifically, I've been trying to think of any examples of such that are driven almost entirely by volunteer based development.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;  A brief VM survey &lt;/h2&gt;&lt;br&gt;The JVM and Dalvik have plenty of full time developers, and the CLR provided by Microsoft not only has full time developers, but also isn't cross platform.&lt;br&gt;Mono's core development was funded directly by first Ximian, then Novell and now Xamarin, and since the CLR is free-threaded, free-threading support would have been a requirement from the start.&lt;br&gt;&lt;br&gt;However, if we switch over to the dynamic language specific VM side, the reference implementations for both Python and Ruby use a Global Interpreter Lock to ease maintenance and maximise speed of execution in the original single-threaded scripting use case. This means neither can scale to multiple cores without using either multiple processes and some form of inter-process communications, or else invoking code that doesn't need to hold the interpreter lock (e.g. C extensions for CPython).&lt;br&gt;&lt;br&gt;Both Python and Ruby have JVM and CLR implementations that &lt;i&gt;are&lt;/i&gt; free-threaded (Jython, JRuby, IronPython, IronRuby), since they can take advantage of  the cross platform threading primitives in the underlying corporate sponsored VM.&lt;br&gt;&lt;br&gt;Rubinius, with Engine Yard's backing, is creating a free-threaded Ruby interpreter in the form of Rubinius 2.0. In my opinion, they've done something smart by avoiding the Win32 API entirely and just writing POSIX code, leaving the task of dealing with Microsoft's idiosyncratic approach to OS interfaces as a problem for the &lt;a href="http://mingw-w64.sourceforge.net/"&gt;MinGW developers&lt;/a&gt;. Unfortunately (from the point of view of this particular problem), CPython long ago adopted the approach of treating Windows as a first class native build target, rather than requiring the use of a third party POSIX compatibility layer.&lt;br&gt;&lt;br&gt;PyPy is heading in a different direction, focusing on making &lt;a href="http://pypy.org/tmdonate.html"&gt;Software Transactional Memory&lt;/a&gt; a viable approach to concurrency in Python, without the well-known data corruption and deadlock pitfalls of thread-based concurrency.&lt;br&gt;&lt;br&gt;Lua &lt;a href="http://lua-users.org/wiki/ThreadsTutorial"&gt;doesn't support&lt;/a&gt; native threading in the core VM at all - it just has a couple of GIL hooks that are no-ops by default, but can be overridden to implement a GIL.&lt;br&gt;&lt;br&gt;Perl 5 supports threads using the &lt;a href="http://perldoc.perl.org/threads.html"&gt;subinterpreter model&lt;/a&gt; - by default, all state is thread local and you have to take &lt;a href="http://perldoc.perl.org/threads/shared.html"&gt;explicit steps&lt;/a&gt; to make it visible to other threads. Perl also warns that using threads may lead to segfaults when using non-thread-safe modules.&lt;br&gt;&lt;br&gt;Parrot (and thus Perl 6) has a rather &lt;a href="http://docs.parrot.org/parrot/devel/html/docs/pdds/pdd25_concurrency.pod.html"&gt;ambitious concurrency model&lt;/a&gt;, but I have no idea how well it works in practice. With Perl 6 still in development, are there any documented production deployments?&lt;br&gt;&lt;br&gt;Javascript doesn't support full shared memory thread, only &lt;a href="https://developer.mozilla.org/en/Using_web_workers"&gt;Web Worker Threads&lt;/a&gt;. Since objects have to be serialised for inter-thread communication, the model is closer to lightweight processes than it is to shared memory threading.&lt;br&gt;&lt;h2&gt;  Whither CPython?&lt;br&gt;&lt;/h2&gt;&lt;br&gt;CPython doesn't have any full time developers assigned these days -  the PSF budget doesn't stretch that far (yet!), and the companies that  use Python (including PSF sponsor members) are generally (with a couple of notable exceptions) more interested  in paying people to build applications with the versions that exist now  rather than paying them directly to build better versions for use in  the future. That's not to say companies don't contribute code (we see  plenty of corporate contributions in the form of upstream patches from  Linux distro vendors like Red Hat and Canonical, as well as major users  like CCP Games, and companies have sponsored particular development  activities via the PSF, such as Dave Murray's work on email enhancements  that landed in 3.3), just that they don't tend to pay developers to  think about future directions for Python in general.&lt;br&gt;&lt;br&gt;&lt;br&gt;Even when the PythonLabs team (IIRC, Guido van Rossum, Tim  Peters, Barry Warsaw, Jeremy Hylton, Fred Drake, maybe some others) were  being funded by Digital Creations/Zope Corporation:&lt;br&gt;&lt;ul&gt;&lt;li&gt;it still wasn't full time for any of them&lt;/li&gt;&lt;li&gt;multi-core machines were still rare back then&lt;/li&gt;&lt;li&gt;DC/Zope is focused on web applications, which are far more likely to be IO bound than CPU bound&lt;/li&gt;&lt;/ul&gt;In more recent years, and this is the first of the exceptions I mentioned earlier, we had Google paying Guido to spend 20  hours a week guiding the development of Python 3, but that was all about  fixing the Unicode model rather than improving multi-core support.&lt;br&gt;&lt;br&gt;The other exception was the Google funded Unladen Swallow effort, which aimed to bring an LLVM based JIT to CPython. While that effort did result in many improvements to LLVM, and the creation of an excellent benchmark suite for long running Python processes (much of which is still used by PyPy to this day), it &lt;a href="http://qinsb.blogspot.com.au/2011/03/unladen-swallow-retrospective.html"&gt;ultimately failed&lt;/a&gt; in its original aim.&lt;br&gt;&lt;br&gt;&lt;h2&gt;  Formalising and enhancing subinterpreters&lt;/h2&gt;Given the high compatibility risks with existing threaded Python code and especially the risk of segfaults in C extensions that come with making CPython truly free-threaded, the Perl 5 subinterpreter model actually looks like the most promising way forward to me. With that approach, all code execution within a given interpreter is still serialised as normal, while a new communication mechanism would allow data to be safely passed between interpreters.&lt;br&gt;&lt;br&gt;Since it isn't exposed at the Python level, many developers don't realise that CPython already supports the use of &lt;a href="http://docs.python.org/c-api/init.html#sub-interpreter-support"&gt;subinterpreters&lt;/a&gt; to provide some degree of isolation between different pieces of code. The Apache &lt;a href="https://en.wikipedia.org/wiki/Mod_wsgi"&gt;mod_wsgi &lt;/a&gt;module uses this feature to provide some isolation between different WSGI applications running on the same Apache instance.&lt;br&gt;&lt;br&gt;Unfortunately, there are currently quite a few quirks and limitations with this feature, which is why it has never been elevated to a formal part of the language specification and exposed at the Python level. In addition, the GIL is part of the state that is still shared, so exposing the feature as it exists today wouldn't help at all with concurrency goals.&lt;br&gt;&lt;br&gt;That leads to my personal recommendation to anyone that would like to see better thread-based concurrency support in CPython:&lt;br&gt;&lt;ul&gt;&lt;li&gt;Create a CPython fork (either by importing directly from &lt;a href="http://hg.python.org/"&gt;http://hg.python.org/cpython&lt;/a&gt;, or by forking the &lt;a href="https://bitbucket.org/python_mirrors/cpython"&gt;BitBucket mirror&lt;/a&gt;).&lt;/li&gt;&lt;li&gt;Make the subinterpreter support compatible with the PyGilState APIs  (Graham Dumpleton and I will actually be discussing this aspect at  PyConAU next month, so I'd suggest talking to Graham before doing anything on this part)&lt;/li&gt;&lt;li&gt;Create a two-tiered locking scheme, where each interpreter (including the main interpreter) has a Subinterpreter Lock that is used to protect the main eval loop, while the Global Interpreter Lock remains in place to protect state that is shared between interpreters&lt;/li&gt;&lt;li&gt;Use the subinterpreter lock in preference to the GIL to protect most Python code evaluation&lt;/li&gt;&lt;li&gt;Design a mechanism for passing objects between interpreters without serialising or copying them. The CLR application domain design may provide some inspiration here.&lt;/li&gt;&lt;/ul&gt;This is by no means an easy project, but it's the one I see as having the greatest potential for allowing CPython to exploit multiple cores effectively without requiring serialisation of data. I'll also note that whatever mechanism is designed for that last bullet point may potentially translate to efficient communication between local processes via memory mapped files.&lt;br&gt;&lt;br&gt;But no, I'm not going to write it. Given what I work on (task automation and IO bound web and CLI applications), I don't need it personally or professionally, and it's too big a project to realistically attempt as a hobby/language PR exercise.&lt;br&gt;&lt;br&gt;If you're interested in funding efforts to make something like this happen for Python 3.4 (likely coming in early-mid 2014), but don't know how to go about finding developers to work on it, then it's worth getting in touch with the &lt;a href="http://python.org/psf/about/#how-do-i-reach-the-psf"&gt;PSF board&lt;/a&gt;. If you want better thread-based concurrency support in Python and are a Red Hat customer, it also wouldn't hurt to mention it via the appropriate channels :)&lt;br&gt;&lt;br&gt;Update: Added Javascript to the VM survey.</description><category>python</category><category>tech</category><guid>http://www.curiousefficiency.org/posts/2012/07/volunteer-supported-free-threaded-cross.html</guid><pubDate>Wed, 11 Jul 2012 02:58:00 GMT</pubDate></item></channel></rss>